<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Coal Blending Ratio — modified</title>
     <style>
    :root{
      --bg: #F7F8FA;        
      --card: #FFFFFF;      
      --muted: #6b7280;     
      --text: #111827;      
      --accent: #b71c1c;    /* red */
      --green: #16a34a;     /* green */
      --border: #E5E7EB;    
      --input-border: #D1D5DB; 
      --accent-btn: #0f4db2;
      --color-blue-800: oklch(.424 .199 265.638);
    }

    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      padding: 90px 14px 8px; /* top padding increased for navbar */
      /* allow normal page scrolling */
      overflow-x: hidden;
    }

    h1 {
      color: var(--text);
      margin: 8px 0;
      font-size: 1.3rem;
      text-align: left;
    }

    .upload-btn {
      display: inline-block;
      background: #02008a;
      color: #fff;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      margin: 6px 3px;
      border: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
      font-size: 0.85rem;
    }

    .main-container {
      display:flex;
      flex-direction:column;
      gap:14px;
      max-width: 1000px;
      align-items:flex-start;
      
    }

    /* grid: first column is label, next 8 are mills/bunkers + gcv + cost */
    .mills-grid {
      display: grid;
      grid-template-columns: 140px repeat(8, 1fr);
      gap: 6px;
      margin: 8px 0;
      align-items: center;
      font-size: 0.8rem;
      width: 100%;
    }

    .mill {
      background: var(--card);
      border: 1px solid var(--border);
      text-align: center;
      padding: 6px;
      color: var(--text);
      min-height: 34px;
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow: 0 1px 2px rgba(16,24,40,0.03);
      border-radius: 6px;
    }

    /* red state (when sum == 100) */
    .mill.red {
      background: var(--accent);
      color: #fff;
      font-weight:700;
      border: 1px solid rgba(0,0,0,0.08);
    }

    /* green state (default when sum < 100) */
    .mill.green {
      background: var(--green);
      color: #fff;
      font-weight:700;
      border: 1px solid rgba(0,0,0,0.06);
    }

    .mill.coal-flow,
    .mill.gcv,
    .mill.aft-head,
    .mill.cost-head {
      background: #02008a;
      color: #fff;
      font-weight: 600;
    }

    .dropdown {
      width: 105%;
      padding:8px;
      background: #fff;
      color: var(--text);
      border: 1px solid var(--input-border);
      border-radius: 4px;
      box-sizing: border-box;
      font-size: 0.8rem;
    }

    .percentage-input, .flow-input, .cost-input, .generation-input, .capacity-input, .next-blend-box {
      width: 88%;
      padding:6px;
      background: #fff;
      border:1px solid var(--input-border);
      color: var(--text);
      text-align:center;
      border-radius: 4px;
      box-sizing: border-box;
      outline: none;
      font-size: 0.8rem;
    }

    .percentage-input{
      border:2px solid #02008a
    }

    .percentage-input::placeholder, .flow-input::placeholder, .cost-input::placeholder {
      color: var(--muted);
    }
.flow-input{
  border:2px solid #F1C40F
}

.generation-input{
  border:2px solid #F1C40F
}
    .cost-input { border:2px solid #F1C40F; background:#fff; }

    .gcv-box {
      width: 92%;
      padding:6px;
      text-align:center;
      font-weight:700;
      background:#F3F4F6;
      border:1px solid var(--input-border);
      color: var(--text);
      border-radius: 4px;
      box-sizing: border-box;
      font-size: 0.8rem;
    }

    .aft { min-height: 28px; color: var(--text); }

   .navbar {
            
            width: 100%;
            background-color: #f7f8fa;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            color: white;
            position: fixed;
            top: 0;
            left: 0;
            height: 65px;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .navbar img {
            height: 95px;
            margin-right: 10px;
            margin-left: 0px;
        }

        .nav-buttons {
            display: flex;
            gap: 10px; /* Use 'gap' for spacing between flex items */
            margin-right: 20px;
            
        }

        .navbar h1 {
            margin-left: 0px;
            font-size: 20px; /* Adjust font size as needed */
            color: black;
            
        }

       .navbar button {
            padding: 10px 15px;
            background-color: #02008a;
            color: #ffffff;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            margin-right: 20px;
            font-weight: bold;
        }
        
        .navbar button:hover {
            background-color: #001cbb;
        }
    /* compact adjustments to avoid scrolling */
    body {
      padding: 80px 6px 6px; /* reduce padding */
    }

    .mills-grid {
      gap: 4px;
      font-size: 0.72rem;
    }

    .mill {
      padding: 4px;
      min-height: 28px;
      font-size: 0.72rem;
    }

    .dropdown,
    .percentage-input,
    .flow-input,
    .cost-input,
    .gcv-box,
    .generation-input, .capacity-input, .next-blend-box {
      font-size: 0.72rem;
      padding: 4px;
    }
    .dropdown {
  font-size:0.6rem;
    }
       #downloadPDF {
  position: fixed;
  top: 100px;
  right: 20px;
  background: #02008a; 
  color: #fff;
  border: none;
  padding: 10px 18px;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  box-shadow: 0 4px 10px rgba(0,0,0,0.15);
  transition: all 0.3s ease;
  z-index: 9999; /* keeps it above everything */
}

#downloadPDF:hover {
  background: #1e40af;
  transform: translateY(-2px);
  box-shadow: 0 6px 14px rgba(0,0,0,0.2);
}
.navbar .logout-btn {
  padding: 10px 16px;
  background-color: red !important;
  color: #fff !important;
  border: none;
  cursor: pointer;
  border-radius: 25px;
  font-weight: bold;
  transition: all 0.3s ease;
}

.navbar .logout-btn:hover {
  background-color: darkred !important;
}
  .icon-btn {
  background: #02008a;  /* same as navbar */
  color: #fff;
  border: none;
  padding: 12px;
  border-radius: 50%;
  font-size: 18px;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  box-shadow: 0 4px 10px rgba(0,0,0,0.12);
}


/* Tooltip */
.icon-btn::after {
  content: attr(title);
  position: absolute;
  bottom: -35px;
  left: 50%;
  transform: translateX(-50%);
  background: #000;
  color: #fff;
  font-size: 12px;
  padding: 5px 8px;
  border-radius: 6px;
  opacity: 0;
  white-space: nowrap;
  pointer-events: none;
  transition: opacity 0.3s ease;
}

.icon-btn:hover::after {
  opacity: 1;
}

/* layout styles used inside grid cell */
.layout {
    position: relative;
    transform-origin: top left;
}

/* bunker grid inside the layout - aligned to the 6 bunker columns */
.bunkers-grid {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  gap: 18px;
  align-items: end;
}

.bunker {
  width: 100%;
  max-width: 120px;
  height: 160px;
  position: relative;
  display:flex;
  flex-direction:column;
  align-items:center;
}

.bunker svg {
  width: 100%;
  height: 120px;
}

.bunker path {
  fill: none;
  stroke: black;
  stroke-width: 2px;
}

.label {
  text-align: center;
  margin-top: -6px;
  font-weight: bold;
}

/* top horizontal line and arrows now positioned relative to the layout wrapper */
.layout .top-line {
  position: absolute;
  top: 0;
  left: -10px; /* start a bit earlier than first arrow */
  width: 590px; /* adjust width to still end at last arrow */
  height: 2px;
  background: black;
}

.layout .arrow {
      position: absolute;
      width: 2px;
      background: black;
}

.layout .arrow::after {
      content: '';
      position: absolute;
      left: -6px;
      bottom: 0;
      border-left: 7px solid transparent;
      border-right: 7px solid transparent;
      border-top: 10px solid black;
}

/* the container we place inside the grid so it aligns with columns 2..7 */
.diagram-in-grid {
  grid-column: 2 / 8; /* align under the 6 bunker columns */
  padding: 6px;
}

/* make summary fixed to the right side of the page (keeps same class name) */
.summary-table {
  position: fixed;
  right: 250px;
  top: 140px; /* below navbar */
  z-index: 9998;
}

    .summary-table {
      display: grid;
      grid-template-columns: 140px 110px;
      gap:6px;
      width:260px;
      margin-bottom:14px;
      font-size: 0.8rem;
      background: transparent;
    }

    .summary-cell {
      background: var(--card);
      border:1px solid var(--border);
      padding:8px;
      color:var(--text);
      text-align:center;
      border-radius:6px;
    }

    .summary-header {
      background:#F3F4F6;
      font-weight:700;
      color:var(--text);
    }

    .summary-cell.summary-header {
      background: #02008a;
      font-weight: 700;
      color: #fff;
    }

    #loader { display:none; color:var(--muted); margin-top:4px; font-size:0.8rem; }

    /* Media query for screens smaller than 900px */
@media (max-width: 900px) {
  body {
    padding: 80px 6px 6px;
  }

  .main-container {
    max-width: 100%;
    align-items: stretch; /* allow children to expand full width on mobile */
  }

  .mills-grid {
    grid-template-columns: 1fr; /* stack columns vertically */
    gap: 6px;
    font-size: 0.72rem;
  }

  .mill {
    width: 100%;
    min-height: 28px;
    font-size: 0.72rem;
    padding: 4px;
  }

  .dropdown,
  .percentage-input,
  .flow-input,
  .cost-input,
  .gcv-box,
  .generation-input {
    width: 100%;
    font-size: 0.72rem;
    padding: 4px;
  }

  /* when stacked, diagram goes full width and summary sits below */
  .diagram-in-grid { grid-column: 1 / -1; }
  .diagram-in-grid .layout { transform: scale(0.9); }

  .diagram-row {
    flex-direction: column;
    gap: 12px;
  }

  .diagram-row .layout {
    transform: scale(0.7); /* scale diagram for smaller screen */
    width: 100%;
  }

  /* MAIN CHANGE: make the summary table static and full-width on mobile
     This lets it sit below the main content in the DOM (so it appears under the table)
     and allow the page to scroll naturally when content is tall. */
  .summary-table {
    position: static !important;
    right: auto !important;
    top: auto !important;
    z-index: auto;
    width: 100% !important;
    max-width: 100%;
    margin: 12px 0 18px 0;
    grid-template-columns: 1fr 1fr; /* 2-column layout that fits mobile */
    gap: 8px;
    padding: 6px;
    box-sizing: border-box;
  }

  .top-line {
    width: 100%; /* stretch top line */
    left: 0;
  }

  .arrow {
    left: auto !important; /* remove fixed left positions */
    margin-left: calc(50% - 1px); /* center arrows */
  }

  #downloadPDF {
    top: auto;
    bottom: 20px;
    right: 10px;
  }

  .navbar img {
    height: 60px; /* reduce logo size */
  }

  .navbar h1 {
    font-size: 16px;
  }

  .nav-buttons {
    flex-direction: column;
    gap: 6px;
    margin-right: 0;
  }
}
/* ---------- responsive summary fixes (paste at end of your stylesheet) ---------- */

/* 1) On large screens keep the summary fixed but make main area leave room */
@media (min-width: 1201px) {
  .summary-table {
    position: fixed;
    right: 250px;     /* unchanged desktop position */
    top: 140px;
    width: 260px;
    z-index: 9998;
  }

  /* leave room so fixed summary doesn't overlap content */
  .main-container {
    margin-right: 320px; /* > summary width to avoid overlap on wide screens */
  }
}

/* 2) On medium screens (where collision often happens) drop summary below */
@media (max-width: 1200px) and (min-width: 901px) {
  .summary-table {
    position: static !important;   /* make it part of normal flow */
    width: 320px;                  /* narrower so it fits under content nicely */
    max-width: 100%;
    margin: 12px 0 18px 0;
    z-index: auto;
    grid-template-columns: 1fr 1fr;
    box-sizing: border-box;
  }

  .main-container {
    margin-right: 0; /* remove extra margin */
  }
}

/* 3) Mobile: full-width summary below the table, no overlap, scrollable */
@media (max-width: 900px) {
  .summary-table {
    position: static !important;
    right: auto !important;
    top: auto !important;
    z-index: auto;
    width: 100% !important;
    max-width: 100%;
    margin: 12px 0 18px 0;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    padding: 6px;
    box-sizing: border-box;
  }

  .main-container {
    margin-right: 0;
    align-items: stretch; /* so inputs expand full width */
  }
}

/* Optional small tweak: make sure any absolutely-positioned elements inside the layout
   do not overflow into the summary area by allowing the layout to wrap/scale. */
.diagram-in-grid,
.layout {
  max-width: 100%;
  box-sizing: border-box;
  overflow: visible;
}

/* Ensure the page can scroll vertically when summary becomes long on mobile */
html, body {
  height: auto;
  overflow-y: auto;
}


  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
if(localStorage.getItem('isLoggedIn') !== 'true') {
    alert('You must login first!');
    window.location.href = '/public/login.html'; 
} else {
    document.body.style.display = 'block';
}
    function logoutUser() {
  localStorage.setItem('isLoggedIn', 'false'); 
  window.location.href = '/public/login.html'; 
}
</script>
</head>
<body>
 <div class="navbar">
    <img src="/public/images/abhitech-logo.png" alt="Company Logo">
    <h1>COAL BLENDING RATIO</h1>
    <div class="nav-buttons">
      <button class="logout-btn" onclick="logoutUser()">Logout</button>
    </div>
  </div>

  <div style="margin-top:8px; display:flex; gap:10px; align-items:center;">
    <button id="saveBtn" class="upload-btn">Submit</button>
    <!-- generation moved to top as requested -->
  </div>

  <div id="loader">Loading... please wait</div>
<button id="downloadPDF" class="icon-btn" title="Download page as PDF">⬇️</button>

  <div class="main-container">
    <div class="mills-grid" id="millsGrid">
      <!-- header row -->
      <div></div>
      <div class="mill green">BUNKER 1</div>
      <div class="mill green">BUNKER 2</div>
      <div class="mill green">BUNKER 3</div>
      <div class="mill green">BUNKER 4</div>
      <div class="mill green">BUNKER 5</div>
      <div class="mill green">BUNKER 6</div>
      <div class="mill gcv">GCV(Kcal/kg)</div>
      <div class="mill cost-head">Cost/MT</div>

      <!-- Row 1: Coal name select & % under mills -->
      <div class="mill">
        <select class="dropdown" id="coalName1">
          <option value="">Select coal</option>
        </select>
      </div>
      <div class="mill"><input type="text" class="percentage-input" data-row="1" data-mill="0" placeholder="%"></div>
      <div class="mill"><input type="text" class="percentage-input" data-row="1" data-mill="1" placeholder="%"></div>
      <div class="mill"><input type="text" class="percentage-input" data-row="1" data-mill="2" placeholder="%"></div>
      <div class="mill"><input type="text" class="percentage-input" data-row="1" data-mill="3" placeholder="%"></div>
      <div class="mill"><input type="text" class="percentage-input" data-row="1" data-mill="4" placeholder="%"></div>
      <div class="mill"><input type="text" class="percentage-input" data-row="1" data-mill="5" placeholder="%"></div>
      <div class="mill"><input type="text" id="gcvBox1" class="gcv-box" placeholder="GCV"></div>
      <div class="mill"><input type="text" id="costBox1" class="cost-input" placeholder="Cost/MT"></div>

      <!-- Row 2 -->
      <div class="mill">
        <select class="dropdown" id="coalName2">
          <option value="">Select coal</option>
        </select>
      </div>
      <div class="mill"><input type="text" class="percentage-input" data-row="2" data-mill="0" placeholder="%"></div>
      <div class="mill"><input type="text" class="percentage-input" data-row="2" data-mill="1" placeholder="%"></div>
      <div class="mill"><input type="text" class="percentage-input" data-row="2" data-mill="2" placeholder="%"></div>
      <div class="mill"><input type="text" class="percentage-input" data-row="2" data-mill="3" placeholder="%"></div>
      <div class="mill"><input type="text" class="percentage-input" data-row="2" data-mill="4" placeholder="%"></div>
      <div class="mill"><input type="text" class="percentage-input" data-row="2" data-mill="5" placeholder="%"></div>
      <div class="mill"><input type="text" id="gcvBox2" class="gcv-box" placeholder="GCV"></div>
      <div class="mill"><input type="text" id="costBox2" class="cost-input" placeholder="Cost/MT"></div>

      <!-- Row 3 -->
      <div class="mill">
        <select class="dropdown" id="coalName3">
          <option value="">Select coal</option>
        </select>
      </div>
      <div class="mill"><input type="text" class="percentage-input" data-row="3" data-mill="0" placeholder="%"></div>
      <div class="mill"><input type="text" class="percentage-input" data-row="3" data-mill="1" placeholder="%"></div>
      <div class="mill"><input type="text" class="percentage-input" data-row="3" data-mill="2" placeholder="%"></div>
      <div class="mill"><input type="text" class="percentage-input" data-row="3" data-mill="3" placeholder="%"></div>
      <div class="mill"><input type="text" class="percentage-input" data-row="3" data-mill="4" placeholder="%"></div>
      <div class="mill"><input type="text" class="percentage-input" data-row="3" data-mill="5" placeholder="%"></div>
      <div class="mill"><input type="text" id="gcvBox3" class="gcv-box" placeholder="GCV"></div>
      <div class="mill"><input type="text" id="costBox3" class="cost-input" placeholder="Cost/MT"></div>

      <!-- diagram, flows, aft rows unchanged -->
      <div></div>
      <div class="diagram-in-grid" style="padding:8px;">
        <div class="layout">
          <div class="top-line"></div>
          <div class="arrow" style="height:60px; left:40px;"></div>
          <div class="arrow" style="height:60px; left:150px;"></div>
          <div class="arrow" style="height:60px; left:255px;"></div>
          <div class="arrow" style="height:60px; left:365px;"></div>
          <div class="arrow" style="height:60px; left:470px;"></div>
          <div class="arrow" style="height:60px; left:580px;"></div>

          <div class="bunkers-grid">
            <!-- six bunkers (same as before) -->
            <div class="bunker"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"><path d="M10 10 V100 L45 140 M55 140 L90 100 V10" /></svg><div class="label">Bunker 1</div></div>
            <div class="bunker"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"><path d="M10 10 V100 L45 140 M55 140 L90 100 V10" /></svg><div class="label">Bunker 2</div></div>
            <div class="bunker"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"><path d="M10 10 V100 L45 140 M55 140 L90 100 V10" /></svg><div class="label">Bunker 3</div></div>
            <div class="bunker"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"><path d="M10 10 V100 L45 140 M55 140 L90 100 V10" /></svg><div class="label">Bunker 4</div></div>
            <div class="bunker"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"><path d="M10 10 V100 L45 140 M55 140 L90 100 V10" /></svg><div class="label">Bunker 5</div></div>
            <div class="bunker"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"><path d="M10 10 V100 L45 140 M55 140 L90 100 V10" /></svg><div class="label">Bunker 6</div></div>
          </div>
        </div>
      </div>
      <div ></div>
      <div ></div>

      <div class="mill coal-flow">Coal Flow(TPH)</div>
      <div class="mill"><input type="text" class="flow-input" data-mill="0" placeholder="TPH"></div>
      <div class="mill"><input type="text" class="flow-input" data-mill="1" placeholder="TPH"></div>
      <div class="mill"><input type="text" class="flow-input" data-mill="2" placeholder="TPH"></div>
      <div class="mill"><input type="text" class="flow-input" data-mill="3" placeholder="TPH"></div>
      <div class="mill"><input type="text" class="flow-input" data-mill="4" placeholder="TPH"></div>
      <div class="mill"><input type="text" class="flow-input" data-mill="5" placeholder="TPH"></div>
      <div></div>
      <div></div>

      <div class="mill aft-head">AFT(°C)</div>
      <div class="mill aft" data-mill="0">--</div>
      <div class="mill aft" data-mill="1">--</div>
      <div class="mill aft" data-mill="2">--</div>
      <div class="mill aft" data-mill="3">--</div>
      <div class="mill aft" data-mill="4">--</div>
      <div class="mill aft" data-mill="5">--</div>
      <div></div>
      <div></div>

      <!-- NEW ROW: Next Blend (computed) -->
      <div class="mill">Next Coal Blend</div>
      <div class="mill"><input type="text" id="nextBlend0" class="next-blend-box" readonly></div>
      <div class="mill"><input type="text" id="nextBlend1" class="next-blend-box" readonly></div>
      <div class="mill"><input type="text" id="nextBlend2" class="next-blend-box" readonly></div>
      <div class="mill"><input type="text" id="nextBlend3" class="next-blend-box" readonly></div>
      <div class="mill"><input type="text" id="nextBlend4" class="next-blend-box" readonly></div>
      <div class="mill"><input type="text" id="nextBlend5" class="next-blend-box" readonly></div>
      <div></div>
      <div></div>

    </div>
  </div>

<!-- Hidden summary (unchanged IDs used by DB save) -->
<div id="summaryHidden" style="display:none;">
  <div id="totalFlow">0</div>
  <div id="avgGCV">0</div>
  <div id="avgAFT">--</div>
  <div id="heatRate">--</div>
  <div id="COSTRATE">--</div>
</div>

<!-- Visible small summary (this is where we put single bunker capacity and generation)
     NOTE: generation input id changed to generationTop, bunker capacity added with id 'bunkerCapacity' -->
<div class="summary-table" aria-hidden="false">
  <div class="summary-cell summary-header">Generation (MW)</div>
  <div class="summary-cell"><input id="generation" class="generation-input" placeholder="MW" /></div>

  <div class="summary-cell summary-header">Bunker Capacity (MT)</div>
  <div class="summary-cell"><input id="bunkerCapacity" class="capacity-input" placeholder="MT" /></div>
</div>


<!-- Calculation script (keeps all existing logic but now pulls oxide/GCV/cost from DB if available) -->
<script>
/* Replacement script — copy & paste this entire <s block
   into your HTML (replace the existing script). It preserves all original
   functionality (GCV/AFT/cost/heatRate, PDF export, save payload, select coloring)
   and only changes:
     - how colours are placed into bunker: the 3rd coal (row 3) appears at the bottom,
       row2 in middle, row1 on top (visual hierarchy reversed compared to dropdown order)
     - timers are independent per bunker and consume bottom -> middle -> top sequentially
     - visual "consumption" effect: the active layer's visible height shrinks as its timer runs
*/

/* ---------- Helper / config ---------- */
const DEFAULT_COAL_COLORS = ["#f39c12","#3498db","#2ecc71","#ef4444","#8b5cf6","#14b8a6","#f97316","#06b6d4"];

function calcAFT(ox){
  const total = Object.values(ox).reduce((a,b)=>a+b,0);
  if(total === 0) return 0;
  const sum = (ox["SiO2"]||0) + (ox["Al2O3"]||0);
  let aft = 0;
  if(sum < 55){
    aft = 1245 + (1.1*(ox["SiO2"]||0)) + (0.95*(ox["Al2O3"]||0)) - (2.5*(ox["Fe2O3"]||0)) - (2.98*(ox["CaO"]||0)) - (4.5*(ox["MgO"]||0)) - (7.89*((ox["Na2O"]||0) + (ox["K2O"]||0))) - (1.7*(ox["SO3"]||0)) - (0.63*(ox["TiO2"]||0));
  } else if(sum < 75){
    aft = 1323 + (1.45*(ox["SiO2"]||0)) + (0.683*(ox["Al2O3"]||0)) - (2.39*(ox["Fe2O3"]||0)) - (3.1*(ox["CaO"]||0)) - (4.5*(ox["MgO"]||0)) - (7.49*((ox["Na2O"]||0) + (ox["K2O"]||0))) - (2.1*(ox["SO3"]||0)) - (0.63*(ox["TiO2"]||0));
  } else {
    aft = 1395 + (1.2*(ox["SiO2"]||0)) + (0.9*(ox["Al2O3"]||0)) - (2.5*(ox["Fe2O3"]||0)) - (3.1*(ox["CaO"]||0)) - (4.5*(ox["MgO"]||0)) - (7.2*((ox["Na2O"]||0) + (ox["K2O"]||0))) - (1.7*(ox["SO3"]||0)) - (0.63*(ox["TiO2"]||0));
  }
  return Number(aft);
}

function getCoalObjForRow(r){
  const sel = document.getElementById(`coalName${r}`);
  if(!sel || !sel.value) return null;
  const db = window.COAL_DB || [];
  let found = db.find(c => String(c._id) === String(sel.value));
  if(!found) found = db.find(c => String(c.coal || '').toLowerCase() === String(sel.value).toLowerCase());
  return found || null;
}

/* ---------- small util ---------- */
function formatHMS(sec) {
  const s = Math.max(0, Math.floor(sec));
  const hrs = Math.floor(s / 3600);
  const mins = Math.floor((s % 3600) / 60);
  const secs = s % 60;
  return `${String(hrs).padStart(2,'0')}:${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
}

/* ---------- Per-bunker sequential timers (bottom -> middle -> top) ---------- */
/* bunkerTimers[b] = {
     layersSeconds: [botSec, midSec, topSec],
     currentLayer: index (0..2 where 0 => bottom),
     layerRemaining: seconds,
     intervalId: window.setInterval id,
     lastConfig: {layersSeconds, flow, bunkerCapacity}
} */
const bunkerTimers = new Array(6).fill(null);
let lastGlobalBunkerCapacity = parseFloat(document.getElementById('bunkerCapacity')?.value) || 0;

function clearBunkerTimer(i){
  const t = bunkerTimers[i];
  if(t && t.intervalId) clearInterval(t.intervalId);
  bunkerTimers[i] = null;
}
function arraysEqualRounded(a,b){
  if(!a && !b) return true;
  if(!a || !b) return false;
  if(a.length !== b.length) return false;
  for(let i=0;i<a.length;i++){
    if(Math.abs((a[i]||0) - (b[i]||0)) > 1) return false; // allow small rounding diffs
  }
  return true;
}

/* ---------- Bunker visual painting (keeps dropdown coloring behavior) ----------
   Visual hierarchy: row3 -> bottom, row2 -> middle, row1 -> top
   We preserve the select background colouring exactly as before.
*/
function updateBunkerColors(){
  const db = window.COAL_DB || [];
  // determine colors for rows 1..3 (these colors are mapped to the dropdowns as before)
  const rowColors = [];
  for(let r=1;r<=3;r++){
    const sel = document.getElementById(`coalName${r}`);
    let color = DEFAULT_COAL_COLORS[(r-1) % DEFAULT_COAL_COLORS.length];
    if(sel && sel.value){
      const found = db.find(c => String(c._id) === String(sel.value) || String(c.coal||'').toLowerCase() === String(sel.value).toLowerCase());
      if(found && (found.color || found.colour || found.hex)) color = found.color || found.colour || found.hex;
    }
    rowColors[r-1] = color;
    // color the select background to keep original behaviour
    if(sel){
      sel.style.background = color;
      const c = color.replace('#','');
      const rch = parseInt(c.substring(0,2),16), gch = parseInt(c.substring(2,4),16), bch = parseInt(c.substring(4,6),16);
      const lum = 0.2126*rch + 0.7152*gch + 0.0722*bch;
      sel.style.color = (lum < 140) ? '#fff' : '#111';
    }
  }

  // paint bunker SVGs: read percentages for each bunker and draw stacked rects.
  // We use the HTML structure that already exists (six .bunker elements each containing an <svg>).
  const svgWidth = 100, svgHeight = 150, topY = 10, midY = 100, bottomY = 140, usableH = bottomY - topY;
  const outlinePath = `M10 ${topY} L10 ${midY} L45 ${bottomY} L55 ${bottomY} L90 ${midY} L90 ${topY} Z`;

  const bunkers = document.querySelectorAll('.bunker');
  bunkers.forEach((bunkerEl, bIndex) => {
    const svg = bunkerEl.querySelector('svg');
    if(!svg) return;
    // percentages: row1 (top), row2 (mid), row3 (bottom)
    const pTop = parseFloat(document.querySelector(`.percentage-input[data-row="1"][data-mill="${bIndex}"]`)?.value) || 0;
    const pMid = parseFloat(document.querySelector(`.percentage-input[data-row="2"][data-mill="${bIndex}"]`)?.value) || 0;
    const pBot = parseFloat(document.querySelector(`.percentage-input[data-row="3"][data-mill="${bIndex}"]`)?.value) || 0;
    // order for drawing bottom-up is [bottom, middle, top] => indices refer to rowColors: row3->index2, row2->index1, row1->index0
    const percentages = [pTop, pMid, pBot];
    const clipId = `clip-bunker-${bIndex}`;
    let inner = `<defs><clipPath id="${clipId}"><path d="${outlinePath}" /></clipPath></defs>`;

    // Determine visible heights based on timer (shrink active layer)
    const timer = bunkerTimers[bIndex];
    // compute full heights for bottom, mid, top
    const fullBottomH = (Math.max(0, Math.min(100, pBot)) / 100) * usableH;
    const fullMidH = (Math.max(0, Math.min(100, pMid)) / 100) * usableH;
    const fullTopH = (Math.max(0, Math.min(100, pTop)) / 100) * usableH;
    const fullHeights = [fullBottomH, fullMidH, fullTopH]; // bottom, mid, top order for drawing

    // We'll draw bottom first, then mid, then top stacking from bottomY upwards.
    let cum = 0;
    for(let layerIdx=0; layerIdx<3; layerIdx++){
      const fullH = fullHeights[layerIdx];
      if(fullH <= 0) continue;
      // by default visibleH = fullH
      let visibleH = fullH;
      if(timer){
        // timer.currentLayer is 0 => bottom, 1=> mid, 2=>top (same indexing)
        if(layerIdx < timer.currentLayer) {
          visibleH = 0; // fully consumed earlier layer
        } else if(layerIdx === timer.currentLayer) {
          const totalForLayer = timer.layersSeconds[layerIdx] || 1;
          const remaining = timer.layerRemaining || 0;
          visibleH = fullH * Math.max(0, remaining / Math.max(1, totalForLayer));
        } else {
          visibleH = fullH; // untouched upper layers
        }
      }
      const y = bottomY - (cum + visibleH);
      cum += visibleH;
      const fillColor = rowColors[2 - layerIdx] || DEFAULT_COAL_COLORS[(2 - layerIdx) % DEFAULT_COAL_COLORS.length];
      // rowColors mapping: row1->index0, row2->index1, row3->index2.
      // layerIdx 0 => bottom -> row3 => rowColors[2], etc.
      if(visibleH > 0){
        inner += `<rect x="0" y="${y}" width="${svgWidth}" height="${visibleH}" fill="${fillColor}" clip-path="url(#${clipId})" />`;
      }
    }

    // outlines/edges
    inner += `<path d="M10 ${topY} L10 ${midY}" stroke="black" fill="none" stroke-width="2" />`;
    inner += `<path d="M90 ${topY} L90 ${midY}" stroke="black" fill="none" stroke-width="2" />`;
    inner += `<path d="M10 ${midY} L45 ${bottomY}" stroke="black" fill="none" stroke-width="2" />`;
    inner += `<path d="M90 ${midY} L55 ${bottomY}" stroke="black" fill="none" stroke-width="2" />`;

    svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
    svg.innerHTML = inner;
  });
}

/* ---------- Timer logic: compute per-layer durations and start/maintain independent timers ---------- */

/* Compute seconds for each layer (bottom, mid, top) for bunker index b:
   formula: hours = ((pct/100) * bunkerCapacity) / flow  -> seconds = hours * 3600
*/
function computeLayerSeconds(b){
  const bunkerCapacity = parseFloat(document.getElementById('bunkerCapacity')?.value) || 0;
  const flow = parseFloat(document.querySelector(`.flow-input[data-mill="${b}"]`)?.value) || 0;
  const pTop = parseFloat(document.querySelector(`.percentage-input[data-row="1"][data-mill="${b}"]`)?.value) || 0;
  const pMid = parseFloat(document.querySelector(`.percentage-input[data-row="2"][data-mill="${b}"]`)?.value) || 0;
  const pBot = parseFloat(document.querySelector(`.percentage-input[data-row="3"][data-mill="${b}"]`)?.value) || 0;

  const pctArr = [pBot, pMid, pTop]; // order bottom, mid, top
  const seconds = pctArr.map(p => {
    if(flow <= 0 || bunkerCapacity <= 0 || p <= 0) return 0;
    const hours = (p / 100.0) * bunkerCapacity / flow;
    return hours * 3600;
  });
  return seconds;
}

/* Start or restart a bunker sequence only for that bunker.
   - If config hasn't changed (rounded), we leave the timer running (important for independence).
*/
function startOrUpdateBunkerTimer(b, layerSeconds, flow, bunkerCapacity){
  // normalize input
  const normalized = layerSeconds.map(s => Math.max(0, Math.round(s)));
  const existing = bunkerTimers[b];
  const newCfg = { layersSeconds: normalized.slice(), flow: flow||0, bunkerCapacity: bunkerCapacity||0 };

  // if an existing timer is running and config matches, do nothing (preserve independence)
  if(existing && existing.intervalId && existing.lastConfig && arraysEqualRounded(existing.lastConfig.layersSeconds, newCfg.layersSeconds) && Math.abs((existing.lastConfig.flow||0)-(newCfg.flow||0))<1e-6 && Math.abs((existing.lastConfig.bunkerCapacity||0)-(newCfg.bunkerCapacity||0))<1e-6){
    return;
  }

  // otherwise clear existing and start fresh sequence
  clearBunkerTimer(b);
  // find first non-zero layer to start at (should be bottom index 0 if any bottom >0)
  let startIndex = 0;
  while(startIndex < normalized.length && (normalized[startIndex] || 0) <= 0) startIndex++;
  if(startIndex >= normalized.length){
    // no layers to consume
    updateNextBlendDisplay(b, 0);
    updateBunkerColors(); // render static fill
    return;
  }

  const timerObj = {
    layersSeconds: normalized,       // [bot, mid, top]
    currentLayer: startIndex,
    layerRemaining: Math.max(0, normalized[startIndex] || 0),
    lastConfig: newCfg,
    intervalId: null
  };

  // immediate render and display
  updateBunkerColors();
  updateNextBlendDisplay(b, timerObj.layerRemaining);

  timerObj.intervalId = setInterval(() => {
    // tick
    if(timerObj.layerRemaining > 0){
      timerObj.layerRemaining--;
    }
    // if finished current layer -> advance
    if(timerObj.layerRemaining <= 0){
      timerObj.currentLayer++;
      if(timerObj.currentLayer >= timerObj.layersSeconds.length){
        // finished all layers
        clearBunkerTimer(b);
        updateNextBlendDisplay(b, 0);
        updateBunkerColors();
        return;
      }
      timerObj.layerRemaining = Math.max(0, timerObj.layersSeconds[timerObj.currentLayer] || 0);
      // update immediately after switching
      updateBunkerColors();
      updateNextBlendDisplay(b, timerObj.layerRemaining);
      return;
    }
    // update visuals as layer shrinks
    updateBunkerColors();
    updateNextBlendDisplay(b, timerObj.layerRemaining);
  }, 1000);

  bunkerTimers[b] = timerObj;
}

function updateNextBlendDisplay(b, seconds){
  const el = document.getElementById(`nextBlend${b}`);
  if(!el) return;
  if(!isFinite(seconds) || seconds <= 0){ el.value = '--'; el.dataset.seconds = 0; return; }
  el.value = formatHMS(seconds);
  el.dataset.seconds = Math.max(0, Math.floor(seconds));
}

/* ---------- Main calculation (blended GCV/AFT/heatRate/cost) + timer orchestration ---------- */
function getSingleBunkerCapacity(){
  const el = document.getElementById('bunkerCapacity');
  if(!el) return 0;
  return parseFloat(el.value) || 0;
}

function calculateBlended(){
  const gcv1_input = document.getElementById('gcvBox1');
  const gcv2_input = document.getElementById('gcvBox2');
  const gcv3_input = document.getElementById('gcvBox3');

  const coal1 = getCoalObjForRow(1), coal2 = getCoalObjForRow(2), coal3 = getCoalObjForRow(3);
  const gcv1 = (gcv1_input && gcv1_input.value.trim()!=='') ? (parseFloat(gcv1_input.value)||0) : ((coal1 && (coal1.gcv||coal1.GCV))? (parseFloat(coal1.gcv||coal1.GCV)||0):0);
  const gcv2 = (gcv2_input && gcv2_input.value.trim()!=='') ? (parseFloat(gcv2_input.value)||0) : ((coal2 && (coal2.gcv||coal2.GCV))? (parseFloat(coal2.gcv||coal2.GCV)||0):0);
  const gcv3 = (gcv3_input && gcv3_input.value.trim()!=='') ? (parseFloat(gcv3_input.value)||0) : ((coal3 && (coal3.gcv||coal3.GCV))? (parseFloat(coal3.gcv||coal3.GCV)||0):0);

  const oxKeys = ["SiO2","Al2O3","Fe2O3","CaO","MgO","Na2O","K2O","SO3","TiO2"];
  let totalFlow = 0, weightedGCV = 0, weightedAFT = 0, contributedAFTFlow = 0;

  const bunkerCapacity = getSingleBunkerCapacity();
  const flowVals = [];

  // detect capacity change (if global bunkerCapacity changed, we will restart timers for all bunkers)
  const capacityChanged = Math.abs((bunkerCapacity || 0) - (lastGlobalBunkerCapacity || 0)) > 1e-6;
  if(capacityChanged) lastGlobalBunkerCapacity = bunkerCapacity;

  for(let m=0;m<6;m++){
    const p1 = parseFloat(document.querySelector(`.percentage-input[data-row="1"][data-mill="${m}"]`)?.value) || 0;
    const p2 = parseFloat(document.querySelector(`.percentage-input[data-row="2"][data-mill="${m}"]`)?.value) || 0;
    const p3 = parseFloat(document.querySelector(`.percentage-input[data-row="3"][data-mill="${m}"]`)?.value) || 0;

    const blendedGCV = (gcv1 * (p1/100)) + (gcv2 * (p2/100)) + (gcv3 * (p3/100));

    // oxide blend
    const ox = {}; let oxTotal = 0;
    oxKeys.forEach(k=>{
      const v1 = coal1 ? (coal1[k] !== undefined ? (parseFloat(coal1[k])||0) : 0) : 0;
      const v2 = coal2 ? (coal2[k] !== undefined ? (parseFloat(coal2[k])||0) : 0) : 0;
      const v3 = coal3 ? (coal3[k] !== undefined ? (parseFloat(coal3[k])||0) : 0) : 0;
      const blended = (v1*(p1/100)) + (v2*(p2/100)) + (v3*(p3/100));
      ox[k] = blended; oxTotal += blended;
    });

    const aftCell = document.querySelector(`.aft[data-mill="${m}"]`);
    if(aftCell){
      if(oxTotal === 0) aftCell.innerText = '--';
      else { const aftVal = calcAFT(ox); aftCell.innerText = isFinite(aftVal) ? Number(aftVal).toFixed(2) : '--'; }
    }

    const flow = parseFloat(document.querySelector(`.flow-input[data-mill="${m}"]`)?.value) || 0;
    flowVals[m] = flow;
    if(flow > 0){
      totalFlow += flow;
      weightedGCV += (flow * blendedGCV);
      const aftText = aftCell ? aftCell.innerText : '--';
      const aftValNumeric = (aftText !== '--') ? (parseFloat(aftText)||0) : null;
      if(aftValNumeric !== null){ weightedAFT += (flow * aftValNumeric); contributedAFTFlow += flow; }
    }
  }

  // handle timers for each bunker individually
  for(let m=0;m<6;m++){
    const layersSec = computeLayerSeconds(m); // [bottom, mid, top]
    const flow = flowVals[m] || 0;
    const existing = bunkerTimers[m];
    if(capacityChanged){
      // when global capacity changed, restart per user's request
      if(layersSec.some(s => s > 1)) startOrUpdateBunkerTimer(m, layersSec, flow, bunkerCapacity);
      else clearBunkerTimer(m);
    } else {
      // only start/restart if config changed
      const existingCfg = existing ? existing.lastConfig : null;
      if(!existingCfg || !arraysEqualRounded(existingCfg.layersSeconds, layersSec) || Math.abs((existingCfg.flow||0)-flow) > 1e-6){
        if(layersSec.some(s => s > 1)) startOrUpdateBunkerTimer(m, layersSec, flow, bunkerCapacity);
        else clearBunkerTimer(m);
      }
      // otherwise leave it running independently
    }
  }

  // update visuals and metrics
  updateBunkerColors();

  const avgGCV = totalFlow > 0 ? (weightedGCV / totalFlow) : 0;
  const avgAFT = contributedAFTFlow > 0 ? (weightedAFT / contributedAFTFlow) : null;

  const hiddenTotalFlow = document.querySelector('#summaryHidden #totalFlow') || document.getElementById('totalFlow');
  if(hiddenTotalFlow) hiddenTotalFlow.innerText = Number(totalFlow).toFixed(2);
  const avgGCVEl = document.getElementById('avgGCV'); if(avgGCVEl) avgGCVEl.innerText = totalFlow>0 ? Number(avgGCV).toFixed(2) : 0;
  const avgAFTEl = document.getElementById('avgAFT'); if(avgAFTEl) avgAFTEl.innerText = (avgAFT!==null) ? Number(avgAFT).toFixed(2) : '--';

  const generationVal = parseFloat(document.getElementById('generation')?.value) || 0;
  const heatRateEl = document.getElementById('heatRate');
  if(generationVal > 0 && totalFlow > 0){
    const heatRate = (totalFlow * avgGCV) / generationVal;
    if(heatRateEl) heatRateEl.innerText = Number(heatRate).toFixed(2);
  } else { if(heatRateEl) heatRateEl.innerText = '--'; }

  // cost (unchanged)
  const cost1 = (document.getElementById('costBox1')?.value.trim()!=='') ? (parseFloat(document.getElementById('costBox1').value)||0) : ((coal1 && (coal1.cost||coal1.Cost)) ? (parseFloat(coal1.cost||coal1.Cost)||0) : 0);
  const cost2 = (document.getElementById('costBox2')?.value.trim()!=='') ? (parseFloat(document.getElementById('costBox2').value)||0) : ((coal2 && (coal2.cost||coal2.Cost)) ? (parseFloat(coal2.cost||coal2.Cost)||0) : 0);
  const cost3 = (document.getElementById('costBox3')?.value.trim()!=='') ? (parseFloat(document.getElementById('costBox3').value)||0) : ((coal3 && (coal3.cost||coal3.Cost)) ? (parseFloat(coal3.cost||coal3.Cost)||0) : 0);
  function getCoalQty(rowIndex){ let total=0; for(let m=0;m<6;m++) total+= parseFloat(document.querySelector(`.percentage-input[data-row="${rowIndex}"][data-mill="${m}"]`)?.value) || 0; return total; }
  const qty1=getCoalQty(1), qty2=getCoalQty(2), qty3=getCoalQty(3);
  const totalCost = (qty1*cost1)+(qty2*cost2)+(qty3*cost3);
  const totalQty = qty1+qty2+qty3;
  const costRate = totalQty>0 ? (totalCost/totalQty) : 0;
  const costRateEl = document.getElementById('COSTRATE'); if(costRateEl) costRateEl.innerText = Number(costRate).toFixed(2);
}

/* ---------- Validation & Listeners (preserve original behaviour) ---------- */
function validateMillPercentages(){
  for(let m=0;m<6;m++){
    let hasPercent=false;
    for(let r=1;r<=3;r++){ const v=parseFloat(document.querySelector(`.percentage-input[data-row="${r}"][data-mill="${m}"]`)?.value)||0; if(v>0){ hasPercent=true; break; } }
    const flow = parseFloat(document.querySelector(`.flow-input[data-mill="${m}"]`)?.value)||0;
    const header = Array.from(document.querySelectorAll('.mills-grid > .mill')).find(el => el.textContent.trim().startsWith(`BUNKER ${m+1}`));
    if(!header) continue;
    header.classList.remove('red','green');
    if(hasPercent && flow > 0) header.classList.add('red'); else header.classList.add('green');
  }
}

function calculateBlendedForBunker(millIndex){
  const bunkerCapacity = parseFloat(document.getElementById('bunkerCapacity')?.value)||0;
  const flow = parseFloat(document.querySelector(`.flow-input[data-mill="${millIndex}"]`)?.value) || 0;
  const layersSeconds = computeLayerSeconds(millIndex);
  const existing = bunkerTimers[millIndex];
  const existingArr = existing ? existing.layersSeconds : null;
  if(!arraysEqualRounded(existingArr, layersSeconds)){
    if(layersSeconds.some(s=>s>1)) startOrUpdateBunkerTimer(millIndex, layersSeconds, flow, bunkerCapacity);
    else clearBunkerTimer(millIndex);
  }
  updateBunkerColors();
}

function attachAutoUpdate(){
  document.querySelectorAll('.percentage-input').forEach(inp=>{
    inp.dataset.prev = inp.value || '';
    inp.addEventListener('focus', function(){ this.dataset.prev = this.value; });
    inp.addEventListener('input', function(){
      const millIndex = Number(this.dataset.mill);
      let sum = 0;
      for(let r=1;r<=3;r++) sum += parseFloat(document.querySelector(`.percentage-input[data-row="${r}"][data-mill="${millIndex}"]`)?.value) || 0;
      if(sum > 100){ this.value = this.dataset.prev || ''; alert(`Total for Mill ${String.fromCharCode(65+millIndex)} cannot exceed 100%.`); calculateBlended(); validateMillPercentages(); updateBunkerColors(); return; }
      this.dataset.prev = this.value;
      // per-bunker recalculation + full blended update (will not restart other unchanged timers)
      calculateBlendedForBunker(millIndex);
      calculateBlended();
      validateMillPercentages();
      updateBunkerColors();
    });
  });

  document.querySelectorAll('.flow-input').forEach(fi=>{
    fi.addEventListener('input', function(){
      const m = Number(this.dataset.mill);
      calculateBlendedForBunker(m);
      calculateBlended();
      validateMillPercentages();
      updateBunkerColors();
    });
  });

  // global inputs: bunkerCapacity & others
  document.querySelectorAll('#bunkerCapacity, #generation, .cost-input, .gcv-box, .dropdown').forEach(el=>{
    el.addEventListener('input', ()=>{
      calculateBlended();
      validateMillPercentages();
      updateBunkerColors();
    });
    el.addEventListener('change', ()=>{
      calculateBlended();
      validateMillPercentages();
      updateBunkerColors();
    });
  });

  // initial run
  calculateBlended();
  validateMillPercentages();
  updateBunkerColors();
}

/* ---------- Save payload (unchanged structure) ---------- */
// async function savePayload(){
//   calculateBlended();
//   const payload = {
//     timestamp: new Date().toISOString(),
//     generation: parseFloat(document.getElementById('generation')?.value) || 0,
//     totalFlow: parseFloat(document.querySelector('#summaryHidden #totalFlow')?.innerText) || parseFloat(document.getElementById('totalFlow')?.innerText) || 0,
//     avgGCV: parseFloat(document.getElementById('avgGCV')?.innerText) || 0,
//     avgAFT: document.getElementById('avgAFT')?.innerText || '--',
//     heatRate: document.getElementById('heatRate')?.innerText || '--',
//     costRate: document.getElementById('COSTRATE')?.innerText || '--',
//     bunkers: []
//   };

//   for(let m=0;m<6;m++){
//     const capacity = 0;
//     const flow = parseFloat(document.querySelector(`.flow-input[data-mill="${m}"]`)?.value) || 0;
//     const p1 = parseFloat(document.querySelector(`.percentage-input[data-row="1"][data-mill="${m}"]`)?.value) || 0;
//     const p2 = parseFloat(document.querySelector(`.percentage-input[data-row="2"][data-mill="${m}"]`)?.value) || 0;
//     const p3 = parseFloat(document.querySelector(`.percentage-input[data-row="3"][data-mill="${m}"]`)?.value) || 0;
//     payload.bunkers.push({ index: m, capacity, flow, percentages: [p1,p2,p3] });
//   }

//   if(window.saveBlend && typeof window.saveBlend === 'function'){
//     try { await window.saveBlend(payload); alert('Saved (via saveBlend).'); return; } catch(e){ console.error(e); alert('saveBlend failed — see console.'); return; }
//   }

//   try{
//     const resp = await fetch('/api/blend', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
//     if(resp.ok) alert('Saved to /api/blend');
//     else { console.warn('save failed', resp.status); alert('Server save failed'); }
//   }catch(err){ console.error(err); alert('Network error saving payload'); }
// }

/* ---------- Boot ---------- */
document.addEventListener('DOMContentLoaded', function(){
  attachAutoUpdate();
  const saveBtn = document.getElementById('saveBtn');
  if(saveBtn) saveBtn.addEventListener('click', savePayload);

  const pdfBtn = document.getElementById('downloadPDF');
  if(pdfBtn) pdfBtn.addEventListener('click', function(){
    try {
      const { jsPDF } = window.jspdf;
      html2canvas(document.body, { scale:2, useCORS:true }).then(canvas=>{
        const imgData = canvas.toDataURL('image/png');
        const pdf = new jsPDF('p','mm','a4');
        const pageW = pdf.internal.pageSize.getWidth();
        const imgW = pageW;
        const imgH = (canvas.height * imgW) / canvas.width;
        let position=0; let heightLeft=imgH;
        pdf.addImage(imgData, 'PNG', 0, position, imgW, imgH);
        heightLeft -= pdf.internal.pageSize.getHeight();
        while(heightLeft>0){ position = heightLeft - imgH; pdf.addPage(); pdf.addImage(imgData, 'PNG', 0, position, imgW, imgH); heightLeft -= pdf.internal.pageSize.getHeight(); }
        pdf.save('Coal_Blending_Ratio.pdf');
      });
    } catch(e){ console.error(e); alert('PDF export failed (see console).'); }
  });
});
</script>

<!-- external JS (replace with the updated input.js below) -->
<script src="/public/input.js"></script>

</body>
</html>
